// Generated by CoffeeScript 1.11.1
var Arguments, Either, NamedFunction, ObjectOrArray, Shape, assertType, define, emptyFunction, formatType, isDev, isType, mergeDefaults, setType;

NamedFunction = require("NamedFunction");

emptyFunction = require("emptyFunction");

mergeDefaults = require("mergeDefaults");

assertType = require("assertType");

formatType = require("formatType");

setType = require("setType");

Either = require("Either");

isType = require("isType");

define = require("define");

Shape = require("Shape");

isDev = require("isDev");

ObjectOrArray = Either(Object, Array);

module.exports = Arguments = NamedFunction("Arguments", function(types) {
  var self;
  assertType(types, ObjectOrArray);
  self = {
    isArray: Array.isArray(types)
  };
  if (isDev) {
    self.types = types;
    self.required = self.isArray;
    if (!self.isArray) {
      self.strict = false;
    }
  }
  return setType(self, Arguments);
});

define(Arguments.prototype, {
  create: emptyFunction.thatReturnsArgument,
  initialize: function(values) {
    if (isDev && (values != null)) {
      assertType(values, Array);
    }
    values = this.create(values != null ? values : []);
    if (!this.isArray) {
      values = values[0];
      if (values == null) {
        values = {};
      }
    }
    if (values != null) {
      assertType(values, this.isArray ? Array : Object);
      if (this.defaults) {
        mergeDefaults(values, this.defaults);
      }
    }
    return values;
  },
  _isArray: function(values) {
    if (Array.isArray(values)) {
      return true;
    }
    return values && isType(values.length, Number);
  }
});

isDev && define(Arguments.prototype, {
  validate: function(values) {
    var error;
    if (this._isArray(values)) {
      if (!this.isArray) {
        throw TypeError("Cannot validate arrays!");
      }
      error = this._validateArray(values, "arguments");
    } else {
      if (this.isArray) {
        throw TypeError("Expected an array!");
      }
      if (!isType(values, Object)) {
        throw TypeError("Expected an object!");
      }
      error = this._validateOptions(values, this.types);
    }
    if (error) {
      if (isType(error, Object)) {
        return TypeError("Expected '" + error.key + "' to be " + (formatType(error.type, true)) + "!");
      } else {
        return error;
      }
    } else {
      return null;
    }
  },
  shouldValidate: {
    get: function() {
      var required;
      required = this.required;
      if (required === true) {
        return emptyFunction.thatReturnsTrue;
      }
      if (required === false) {
        return function(value) {
          return value !== void 0;
        };
      }
      return function(value, key) {
        return required[key] === true;
      };
    }
  },
  _validateArray: function(values, keyPath) {
    var error, i, index, len, ref, shouldValidate, type, types, value;
    ref = this, types = ref.types, shouldValidate = ref.shouldValidate;
    for (index = i = 0, len = types.length; i < len; index = ++i) {
      type = types[index];
      value = values[index];
      if (!shouldValidate(value, index)) {
        continue;
      }
      if (error = this._validateType(value, type, keyPath + ("[" + index + "]"))) {
        return error;
      }
    }
    return null;
  },
  _validateOptions: function(options) {
    var error, key, ref, shouldValidate, type, types, value;
    ref = this, types = ref.types, shouldValidate = ref.shouldValidate;
    if (this.strict) {
      for (key in options) {
        value = options[key];
        if (types[key] === void 0) {
          return Error("'options." + key + "' is not supported!");
        }
      }
    }
    for (key in types) {
      type = types[key];
      value = options[key];
      if (!shouldValidate(value, key)) {
        continue;
      }
      if (error = this._validateType(value, type, "options." + key)) {
        return error;
      }
    }
    return null;
  },
  _validateTypes: function(values, types, keyPath) {
    var error, key, type;
    if (keyPath) {
      keyPath += ".";
    }
    for (key in types) {
      type = types[key];
      if (error = this._validateType(values[key], type, keyPath + key)) {
        return error;
      }
    }
    return null;
  },
  _validateType: function(value, type, key) {
    var error;
    if (isType(type, Object)) {
      if (!isType(value, Object)) {
        return {
          key: key,
          type: Object
        };
      }
      if (error = this._validateTypes(value, type, key)) {
        return error;
      }
    } else if (isType(type, Shape)) {
      if (error = type.assert(value, key)) {
        return error;
      }
    } else if (!isType(value, type)) {
      return {
        key: key,
        type: type
      };
    }
    return null;
  }
});

isDev || Object.assign(Arguments.prototype, {
  validate: emptyFunction
});

Arguments.Builder = (function() {
  var Builder, optionTypes;
  optionTypes = {
    types: ObjectOrArray,
    defaults: ObjectOrArray,
    required: Either(Boolean, ObjectOrArray),
    strict: Boolean,
    create: Function
  };
  Builder = NamedFunction("Arguments_Builder", function() {
    return Object.create(Builder.prototype);
  });
  define(Builder.prototype, {
    set: function(key, value) {
      var optionType;
      if (isDev) {
        if (optionType = optionTypes[key]) {
          assertType(value, optionType, key);
        } else {
          throw Error("Invalid key: '" + key + "'");
        }
      }
      this[key] = value;
    },
    build: function() {
      var args;
      args = Arguments(this.types);
      if (this.defaults) {
        args.defaults = this.defaults;
      }
      if (this.create) {
        args.create = this.create;
      }
      if (isDev) {
        if (this.required != null) {
          args.required = this.required;
        }
        if (this.strict != null) {
          args.strict = this.strict;
        }
      }
      return args;
    }
  });
  return Builder;
})();
